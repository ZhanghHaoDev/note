# 进程之间的关系

## 1. 进程之间的关系 简介

1. 进程组
2. 会话
3. 孤儿进程，僵尸进程，守护进程

### 进程之间的关系 note

1. 每个进程都会有一个父进程，内核的父进程是自己，当子进程结束的时候，会通知父进程
2. 每个进程有一个进程ID，并且属于一个进程组，进程组可以是用户自己定义，也可以系统分配，
3. 进程组会有一个进程组长，进程组长是当前进程组的第一个进程，其进程ID与进程组ID相同
   + 进程组长是创建进程组的时候确定的，一旦确定无法更改
4. 会话：一个或多个进程组的集合，会话的首进程也是组长进程，也是创建会话的第一个进程
5. 孤儿进程（Orphan Process）
孤儿进程是指其父进程已经终止，但孤儿进程仍在运行的进程。当一个进程的父进程终止时，孤儿进程会被 init 进程（通常是 PID 为 1 的进程）收养。init 进程会负责清理孤儿进程的资源。
6. 僵尸进程（Zombie Process）
僵尸进程是指已经终止但其父进程尚未调用 wait 或 waitpid 系统调用获取其终止状态的进程。僵尸进程仍然占用进程表项，但不占用其他系统资源。父进程需要调用 wait 或 waitpid 来清理僵尸进程的资源。
7. 守护进程：是生存期长的一种进程。他们常常在系统引导装入时启动，系统关闭的时候终止，在后台运行，创建守护进程的规则：
   + 首先要做的是调用umaske将文件模式创建屏蔽字设置为一个已知值（0）。由继承的来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。如果守护进程要创建文件，可以设置特定权限
   + 调用fork，然后使得父进程exit。
     + 如果该守护进程是作为一条简单的shell命令启动的，那么父进程终止会让shell认为这条命令已经执行完毕
     + 虽然子进程继承了父进程的进程组ID，但获得了一个新的进程ID，保证了子进程不是一个进程组的组长进程
   + 调用setsid创建一个新会话，调用进程
     + 成为新会话的首进程
     + 成为一个新进程组的组长进程 
     + 没有控制终端
   + 将当前工作目录修改为根目录，使得守护进程的工作目录无法被卸载
   + 关闭不需要的文件描述符

## 2. 进程之间的关系 接口

1. 获取进程的进程组ID/组长ID
+ 函数功能：获取调用进程的进程组 ID
+ 函数原型：
    ```c
    #include <unistd.h>
    pid_t getpgrp(void);
    ```
+ 函数参数：无
+ 函数返回值：成功返回进程组ID，失败返回-1

2. 设置进程的进程组ID
+ 函数功能：设置进程的进程组ID
+ 函数原型：
    ```c
    #include <unistd.h>
    int setpgid(pid_t pid, pid_t pgid);
    ```
+ 函数参数：pid：进程 ID，pgid：进程组 ID
+ 函数返回值：状态码，成功返回0，失败返回-1

3. 创建一个新的会话
+ 函数功能：创建一个新的会话，并将调用进程设置为会话的首进程。
+ 函数原型：
    ```c
    #include <unistd.h>
    pid_t setsid(void);
    ```
+ 函数参数：无
+ 函数返回值：会话ID，失败返回-1

## 3. 进程之间的关系 数据结构