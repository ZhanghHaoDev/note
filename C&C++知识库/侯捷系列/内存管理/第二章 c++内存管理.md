# 第二章 c++内存管理

c++当中的内存分为下面几个区域

1. 栈区（Stack）：由编译器自动分配释放，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈。
2. 堆区（Heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意，与数据结构中的堆是两回事，分配方式倒是类似于链表。
3. 全局/静态存储区（Global/Static）：全局变量和静态变量被分配到同一块内存中。在C++中，全局变量和静态变量在编译时分配内存，存储在一起，程序结束时由操作系统回收。
4. 常量存储区（Constant）：这是一块比较特殊的存储区，它们里面存放的是常量，不允许修改。
5. 代码区（Code）：存放函数体的二进制代码。

以下是对每个区域的详细介绍：

- 栈区：由编译器自动管理，存放函数的参数值，局部变量等。其操作方式类似于数据结构中的栈。
- 堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。在C++中，利用new在堆区申请动态内存。
- 全局/静态存储区：全局变量和静态变量存储在一起，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束时由操作系统回收。
- 常量存储区：这是一块比较特殊的存储区，它们里面存放的是常量，不允许修改。
- 代码区：存放函数体的二进制代码。

在C++中，函数体的二进制代码存储在代码区（Code Segment）。

代码区是内存中的一块特殊区域，用于存储程序的二进制代码。这个区域通常是只读的，以防止程序在运行时意外地修改了其自身的代码。

当你编写一个函数并编译你的程序时，这个函数的机器代码就会被放入代码区。当程序运行并调用这个函数时，CPU就会从代码区读取并执行这个函数的代码。

需要注意的是，虽然函数的代码存储在代码区，但是函数的局部变量和参数值是存储在栈区的。当函数被调用时，其参数值和局部变量会被压入栈中；当函数返回时，这些值会被从栈中弹出。

函数堆栈（Function Stack）或者称为调用堆栈（Call Stack），是计算机科学中的一个重要概念，它在程序执行函数调用时起着关键的作用。

在C++或其他大多数编程语言中，当一个函数被调用时，会为这个函数创建一个新的栈帧（Stack Frame）。这个栈帧包含了函数的局部变量，参数值，以及一些额外的信息，如返回地址（即函数执行完毕后应该跳转回去的位置）。这个栈帧被压入调用堆栈的顶部。

当函数执行完毕返回时，其对应的栈帧就会从调用堆栈的顶部被弹出，控制权返回到之前的函数。这就是为什么函数可以递归调用，而每次调用都有自己的局部变量：每次调用都有自己的栈帧，互不影响。

因此，函数堆栈实际上是一个记录程序执行状态的数据结构，每次函数调用都会在堆栈中压入一个新的栈帧，每次函数返回都会弹出一个栈帧。这种后进先出（LIFO）的特性，使得函数堆栈能够准确地跟踪程序的执行流程。

在C++中，new和delete是用于动态内存管理的关键操作符。

1. new操作符：new操作符用于在堆（Heap）上分配内存。当你使用new操作符创建对象时，C++运行时系统会在堆上找到足够的空间来存储该对象，并返回一个指向新分配内存的指针。例如，int* p = new int;会在堆上分配足够的内存来存储一个int，并将地址赋值给指针p。
2. delete操作符：delete操作符用于释放由new操作符分配的内存。当你不再需要一个由new创建的对象时，你应该使用delete操作符来释放那块内存。例如，delete p;会释放p指向的内存。

在C++中，动态内存管理是非常重要的，因为它允许你在运行时创建和销毁对象。然而，也需要小心，因为如果忘记使用delete释放内存，或者试图访问已经被delete的内存，都可能导致严重的问题，如内存泄漏或程序崩溃。为了避免这些问题，C++11引入了智能指针（如std::unique_ptr和std::shared_ptr），它们可以自动管理new和delete，使得动态内存管理更加安全和容易。

在C++中，内存泄漏是指程序在申请内存后，无法释放已申请的内存空间的一种情况。一旦发生内存泄漏，程序会持续占用越来越多的内存，这可能导致系统资源耗尽，最终导致程序崩溃或系统运行缓慢。

内存泄漏通常发生在程序员使用new操作符动态分配内存，但忘记使用delete操作符来释放它。例如：

int* p = new int;

// ... 使用 p ...

// 忘记 delete p，导致内存泄漏

在上述代码中，我们使用new操作符分配了一块内存，但在使用完后忘记使用delete释放它，导致这块内存无法被再次使用，从而发生了内存泄漏。

为了避免内存泄漏，我们应该养成在每次使用new操作符后，都对应使用delete操作符来释放内存的习惯。此外，C++提供了智能指针（如std::unique_ptr和std::shared_ptr），它们可以自动管理内存，使得内存管理更加安全和容易，从而帮助防止内存泄漏。

在C++中，避免内存泄漏主要有以下几种方法：

1. 使用智能指针：C++标准库提供了几种智能指针类型，如std::unique_ptr，std::shared_ptr和std::weak_ptr。这些智能指针会在适当的时候自动释放它们所拥有的内存，从而避免内存泄漏。

std::unique_ptr<int> p(new int);

1. 使用容器类：C++标准库中的容器类（如std::vector，std::string等）会自动管理内存。使用这些容器类可以避免手动分配和释放内存。

std::vector<int> v;

1. 使用RAII（Resource Acquisition Is Initialization）：这是一种编程技巧，它将资源的生命周期与对象的生命周期绑定。当对象被创建时，它会获取资源；当对象被销毁时，它会释放资源。

class MyClass {

int* buffer;

public:

MyClass(size_t size) {

buffer = new int[size];

}

~MyClass() {

delete[] buffer;

}

};

1. 避免在异常情况下泄漏资源：如果在函数中分配了资源，然后抛出了异常，那么可能会发生资源泄漏。为了避免这种情况，可以使用try/catch块，或者将资源分配和释放放在构造函数和析构函数中。
2. 使用内存泄漏检测工具：有许多工具可以帮助检测C++程序中的内存泄漏，如Valgrind，AddressSanitizer等。

记住，每次使用new分配内存，都应该有一个对应的delete来释放内存。

在C++中，智能指针是一种对象，它像原始指针一样存储了内存地址的引用，但当它们离开作用域或被覆盖时，它们会自动删除所引用的对象。这种自动管理内存的能力可以帮助防止内存泄漏。C++标准库提供了几种类型的智能指针，包括std::unique_ptr，std::shared_ptr和std::weak_ptr。

1. std::unique_ptr：这是最简单的智能指针类型。它表示唯一拥有对象的指针。当std::unique_ptr离开其作用域时，它会自动删除其所拥有的对象。std::unique_ptr不能被复制，只能被移动，这确保了任何时候只有一个std::unique_ptr可以指向给定的对象。
2. std::shared_ptr：这种类型的智能指针允许多个指针拥有同一个对象。std::shared_ptr使用引用计数来跟踪有多少个智能指针共享同一个对象。当最后一个std::shared_ptr离开作用域或被覆盖时，它会删除所拥有的对象。
3. std::weak_ptr：这是一种特殊类型的智能指针，它持有对对象的非拥有（"weak"）引用。std::weak_ptr不会增加std::shared_ptr的引用计数，也不会阻止其所引用的对象被删除。它通常用于解决std::shared_ptr的循环引用问题。

使用智能指针可以使内存管理变得更加简单和安全，但也需要注意正确使用。例如，不应该使用智能指针管理非动态分配的内存，或者让多个智能指针管理同一块内存。

智能指针的工作原理基本上就是在其构造函数中申请内存，并在析构函数中释放内存。这是通过RAII（Resource Acquisition Is Initialization）原则实现的，这是C++中的一种编程技巧，用于管理资源的生命周期。

例如，当你创建一个std::unique_ptr或std::shared_ptr时，你会将一个原始指针传递给它的构造函数。这个原始指针指向一个动态分配的对象。然后，智能指针会接管这个对象的所有权，负责在适当的时候删除它。

当智能指针的实例离开其作用域时，其析构函数会自动被调用。在析构函数中，智能指针会删除它所拥有的对象（使用delete或delete[]），从而释放内存。

这种自动管理内存的方式可以帮助防止内存泄漏，因为你不需要记住在每个可能的退出点手动释放内存。只要智能指针的实例存在，它就会拥有其所指向的对象。当智能指针被销毁时，它也会自动销毁其所拥有的对象。