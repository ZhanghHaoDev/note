# 第五章 参数符重载与返回值

# 5.1 操作符重载-1，成员函数（this）

1. 有两个操作数的符号叫做二元操作符
2. 比如 += 有两个数就叫做二元操作符，符号左边的叫做左值，右边的叫做右值
3. 谁调用，谁就是this，this是指针，所以编译器会自动把c2的值传进来。

// 2-1

inline complex&

__doapl(complex* ths,const complex& r)

{

ths->re += r.re;    // 第一个参数将会被改变

ths->im += r.im;    // 第二个参数不会被改变

return *ths;

}

inline complex&

complex::operator += (const complex& r)

{

return __doaple(this ,r);

}

---

inline complex&

complex::operator += (this , const complex& r)

{

return __doaple(this ,r);

}

---

{

complex c1(2,1);

complex c2(5);

c2 += c1;

}

---

# 5.2 return by reference 语法分析

传递者无需知道接受者是以reference形式接收

c3 += c2 += c1;

---

1. c++在语法上是允许连串使用 操作符的，
2. 需要注意的是：在设计操作符重载的时候，我们一定要考虑的是使用者连串使用操作符。

# 5.3 class之外的各种定义（definitions）

// 2-2

inline double

imag(const complex& x)

{

return x.imag();

}

inline double

real (const complex& x)

{

return x.real();

}

{

complex c1(2,1);

cout << imag(c1);

cout << real(c1);

}

---

# 5.4 操作符重载-2，非成员函数（无this）

为了对付client的三种可能用法，这里对应开发三个函数

// 2-3

inline complex

operator + (const complex& x, const complex& y)

{

return complex (real (x) + real (y),

imag (x) + imag (y));

}

inline complex

operator + (const complex& x, double y)

{

return complex (real (x) + y,imag(x));

}

inline complex

operator + (double x, const complex& y)

{

return complex (x + real (y),iamg (y));

}

{

complex c1(2,1);

complex c2;

c2 = c1 + c2;

c2 = c1 + 5;

c2 = 7 + c1;

}

---

### 5.4.1 temp object (临时对象) typename()

上面这些函数绝对不可以return by reference,因为，他们必须返回的必定是local object。

### 5.4.2 class body之外的各种定义（definitions）

// 2-4 正负号

inline complex

operator + (const complex& x)

{

return x;

}

inline complex

operator - (const complex& x)

{

return complex(-real(x),-imag(x));

}

{

complex c1(2,1);

complex c2;

cout << -c1;

couy << +c1;

}

---

这个函数绝对不可以返回引用，因为返回的必定是value

// 2-5 == 的重载

inline bool

operator == (const complex& x,const complex& y)

{

return real (x) == real(y)

&& imag (x) == imag(y);

}

inline bool

operator == (const complex& x,double y)

{

return real (x) == y && imag (x) == 0;

}

inline bool

operator == (double x,const complex& y)

{

return x == real(y) && imag (y) == 0;

}

{

complex c1(2,1);

complex c2;

cout << (c1 == c2);

cout << (c1 == 2);

cout << (3 ==c1);

}

---

// 2-6 !=的重载

inline bool

operator != (const complex& x,const complex& y)

{

return real (x) != real(y)

&& imag (x) != imag(y);

}

inline bool

operator != (const complex& x,double y)

{

return real (x) != y && imag (x) != 0;

}

inline bool

operator != (double x,const complex& y)

{

return x != real(y) && imag (y) != 0;

}

{

complex c1(2,1);

complex c2;

cout << (c1 != c2);

cout << (c1 != 2);

cout << (3 !=c1);

}

---

// 2-7 共轭复数

// 实部相等，虚部正符号相反就称之为共轭复数

inline complex

conj (const complex& x)

{

return complex (real (x),-imag (y));

}

#include <iostream.h>

ostream&

operator << (osteram& os,const complex& x)

{

return os << '(' << real(x) << ','

<< imag(x) << ')';

}

{

complex c1(2,1);

cout << conj(c1);

cout << c1 << conj (c1);

}

上面输出：

(2,-1)

(2,1)(2,1)

---