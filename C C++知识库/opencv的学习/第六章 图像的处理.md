# 第六章 图像的处理

# 1. 图像颜色空间

# 1.1 RGB颜色模型

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450362-5a990862-cc40-486c-9f15-d59d9c51d772.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450362-5a990862-cc40-486c-9f15-d59d9c51d772.png)

---

- 第一个通道时蓝色（B）分量
- 第二个通道时绿色（G）分量
- 第三个通道时红色（R）分量
1. 图像数据类型间的互相转换

void convertTo(OutputArray m,int rtypr,double alpha,double beta);

---

- m：输出图像
- rtype：转换后数据类型
- alpha：缩放系数
- beta：平移系数

# 1.2 HSV颜色模型

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450473-6557a009-617a-4149-b5eb-59320dd1ee9c.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450473-6557a009-617a-4149-b5eb-59320dd1ee9c.png)

---

- H是色度（Hue）颜色
- S是饱和度（Saturation）深浅
- V是亮度（Value）亮暗

# 1.3 GRAY颜色模型

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450317-f66e0483-4c2e-49ec-826b-81155b87b87c.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450317-f66e0483-4c2e-49ec-826b-81155b87b87c.png)

---

工业上常用，灰度图，只能RGB转灰度图，不能灰度图转RGB

1. 颜色转换

void CVtClor(inputArray src,OutputArray dst,int code,int dstCn)

---

- src：带转换颜色模型的原始图像
- dst： 转换颜色模型后的目标图像
- code：颜色空间转换的标志，如由RGB转到HSV
- dstCn：目标图像中的通道数，如果参数为0，则从src和代码中自动导出通道数

# 1.4 实例

Mat img = imread("./leno.jpg", IMREAD_COLOR);

Mat img_32;

img.convertTo(img_32, CV_32F, 1 / 255.0, 0);

Mat img_hsv_32;

cvtColor(img_32, img_hsv_32, COLOR_BGR2HSV);

Mat img_hsv;

img_hsv_32.convertTo(img_hsv, CV_8U, 255.0, 0);

Mat img_gray, img_gray_32;

cvtColor(img, img_gray, COLOR_BGR2GRAY);

img_gray.convertTo(img_gray_32, CV_32F, 1 / 255.0, 0);

---

# 2. 多通道的分离与合并

# 2.1 多通道的分离

void split(inputArrat m,OutputArray mv);

---

- m：待分离的多通道图像
- mv：分离后的单通道图像，为向量vector形式

# 2.2 多通道的合并

void merge(inputArray mv,outputArray dst);

---

- mv：需要合并的图像向量vector，其中每个图像必须拥有相同的尺寸和数据类型
- dst：合并后输出的图像，通道数等于所有输入图像的通道数总和

# 2.3 实例

Mat img = imread("./leno.jpg", IMREAD_COLOR);

Mat img_32;

img.convertTo(img_32, CV_32F, 1 / 255.0, 0);

Mat img_gray, img_gray_32;

cvtColor(img, img_gray, COLOR_BGR2GRAY);

img_gray.convertTo(img_gray_32, CV_32F, 1 / 255.0, 0);

// 分离

Mat imgs[3];

split(img, imgs);

Mat img0, img1, img2;

img0 = imgs[0];

img1 = imgs[1];

img2 = imgs[2];

// 合并

Mat img_merge;

merge(imgs, 3, img_merge);

---

# 3. 两个图像像素比较

void min(inputArray src1,inputArray src2,outputArray dst);

void max(inputArray src1,inputArray src2,outputArray dst);

---

- src1：第一个图像矩阵，可以是任意通道数的矩阵
- src2：第二个图像矩阵，尺寸和通道数以及数据类型都需要与src1一致
- dst： 保留对应位置较大（较小）灰度值后的图像矩阵，尺寸，通道数和数据类型与src1一致

意思就是说：我们使用min()或max()函数比较图像，结果是较小或较大的图像

# 3.2. 图像最大值与最小值寻找

void minMaxLoc(inputArray src,double* minVal,double* maxVal,Point* minLoc,Point maxLoc

inputArray mask);

---

- src：输入单通道矩阵
- minVal：指向最小值的指针，如果不需要，使用null
- maxVal：指向最大值的指针，如果不需要，则使用null
- minLoc：指向最小值位置的指针，如果不需要，则使用null
- maxLocal：指向最大值位置的指针，如果不需要，则使用null
- mask：掩码矩阵，用于标记寻找上述四个值的范围，参数默认值是noArray()，表示寻找范围是矩阵中所有数据

# 3.3. 实例

Mat img1 = imread("./leno.jpg", IMREAD_COLOR);

Mat white = imread("./R-C.jpg", IMREAD_COLOR);

Mat black = imread("./v2.jpg", IMREAD_COLOR);

// 比较

Mat cmpMin, cmpMax;

min(img1, white, cmpMin);

max(img1, black, cmpMax);

// 定义一个灰度图像

Mat img_gray;

cvtColor(img1, img_gray, COLOR_BGR2GRAY);

double minVal, maxVal;

Point minLoc, maxLoc;

minMaxLoc(img_gray, &minVal, &maxVal, &minLoc, &maxLoc);

---

# 4. 图像像素逻辑运算

# 4.1 两个像素逻辑运算规则

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450347-c4d2ee8b-2de9-49d9-85d0-244ce8bcf8ec.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450347-c4d2ee8b-2de9-49d9-85d0-244ce8bcf8ec.png)

---

# 4.2 两个图像像素逻辑运算函数

void vitwise_not(inputArray src,outputArray dst,inputArray mask);

void bitwise_and(inputArray src1,inpuArray src2,outputArray dst,inputArray mask);

void bitwise_or(inputArray src1,inpuArray src2,outputArray dst,inputArray mask);

void bitwise_xor(inputArray src1,inpuArray src2,outputArray dst,inputArray mask);

---

- vitwise_not() 非运算
- 输入矩阵
- 输出结果
- 掩码矩阵（范围）
- bitwise_and() 与运算
- 输入参数1
- 输入参数2
- 输出结果
- 掩码矩阵（范围）
- bitwise_or()或运算
- 输入参数1
- 输入参数2
- 输出结果
- 掩码矩阵（范围）
- bitwise_xor()异或运算
- 输入参数1
- 输入参数2
- 输出结果
- 掩码矩阵（范围）

# 4.3 实例

Mat img1 = (Mat_<uchar>(1, 2) << 0, 5);

Mat img2 = (Mat_<uchar>(1, 2) << 0, 6);

cout << "img1 = " << endl << img1 << endl << endl;

cout << "img2 = " << endl << img2 << endl << endl;

// 逻辑与

Mat img_and;

bitwise_and(img1, img2, img_and);

cout << "img_and = " << endl << img_and << endl << endl;

// 逻辑或

Mat img_or;

bitwise_or(img1, img2, img_or);

cout << "img_or = " << endl << img_or << endl << endl;

// 逻辑非

Mat img_not;

bitwise_not(img1, img_not);

cout << "img_not = " << endl << img_not << endl << endl;

// 逻辑异或

Mat img_xor;

bitwise_xor(img1, img2, img_xor);

cout << "img_xor = " << endl << img_xor << endl << endl;

// 图像的逻辑运算

Mat imgw = imread("./leno.jpg", IMREAD_COLOR);

Mat imgs = imread("./R-C.jpg", IMREAD_COLOR);

Mat img_and2;

bitwise_and(imgw, imgs, img_and2);

Mat img_or2;

bitwise_or(imgw, imgs, img_or2);

Mat img_not2;

bitwise_not(imgw, img_not2);

Mat img_xor3;

bitwise_xor(imgw, imgs, img_xor3);

---

# 5. 图像的二值化

二值化处理的图像会自动将彩色图片转换为灰度图

# 5.1 固定阈值二值化

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450377-c6eda19a-2050-41c9-b2c0-f29b8c6aaf36.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320450377-c6eda19a-2050-41c9-b2c0-f29b8c6aaf36.png)

---

大概意思是：比如输入一个信号，信号的样式是尖峰式的[[🎨image.png]](https://cdn.nlark.com/yuque/0/2023/png/33648751/1682936257004-b73077ca-cde5-418e-91c0-42dd9e753584.png#averageHue=%23f5f6f2&clientId=u677624b0-e21e-4&from=paste&height=44&id=u1d7992e4&originHeight=44&originWidth=190&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11787&status=done&style=none&taskId=u92c39139-8006-40b8-9b90-af77873e680&title=&width=190)，经过我们处理，将这种信号处理成为[[🎨image.png]](https://cdn.nlark.com/yuque/0/2023/png/33648751/1682936284579-c16d522b-2bfc-4d10-b7cf-c3fd5a44ec97.png#averageHue=%23eeeeec&clientId=u677624b0-e21e-4&from=paste&height=48&id=u490b70d1&originHeight=48&originWidth=186&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7646&status=done&style=none&taskId=u083e2824-0c81-4db1-9fd7-d5d13dded10&title=&width=186)，这种高低的形式，而高低只有高和低两种形式，所以称之为二值

1. 函数

double threshold(inputArray src,outputArray dst,double thesh,double maxval,int type);

---

- src：待处理的图像，图像只能是CV_8U和CV_32F两种数据类型，对于图像通道数目的要求和选择二值化方法相关
- dst：二值化后的图像，与输入图像具有相同的尺寸，数据类型和通道数
- thresh：二值化的阈值
- maxval：二值化过程的最大值
- type：选择图像二值化方法的标志

# 5.2 实例

Mat img = imread("./leno.jpg", IMREAD_GRAYSCALE);

// 二值化

Mat img_binary;

threshold(img, img_binary, 100, 255, THRESH_BINARY);

imshow ("img_binary", img_binary);

// 反二值化

Mat img_binary_inv;

threshold(img, img_binary_inv, 100, 255, THRESH_BINARY_INV);

imshow("img_binary_inv", img_binary_inv);

waitKey (0);

---

# 5.3 自适应阈值二值化

double adaptiveThreshold(inputArray src,outputArray dst,double thesh,

double maxval,int adaptiveMethod,int thresholdType,

int blocksize double C);

---

- src：待处理的图像，图像只能是CV_8U和CV_32F两种数据类型，对于图像通道数目的要求和选择二值化方法相关
- dst：二值化后的图像，与输入图像具有相同的尺寸，数据类型和通道数
- thresh：二值化的阈值
- adaptiveMethod：自制应确定阈值的方法，分为均值法和高斯法
- thresholdType：选择图像二值化的方法的标志
- blocksize：自适应确定阈值的像素邻域大小，一般为3，5，7的奇数
- C：从平均值或加权平均值中减去的阐述，可以为正，也可以为负数

# 5.4 实例

Mat img = imread("./leno.jpg", IMREAD_GRAYSCALE);

// 二值化

Mat img_binary;

threshold(img, img_binary, 100, 255, THRESH_BINARY);

imshow ("img_binary", img_binary);

// 反二值化

Mat img_binary_inv;

threshold(img, img_binary_inv, 100, 255, THRESH_BINARY_INV);

imshow("img_binary_inv", img_binary_inv);

// 自适应阈值二值化

Mat img_adaptive;

adaptiveThreshold(img, img_adaptive, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 15, 10);

imshow("img_adaptive", img_adaptive);

waitKey (0);

---

# 1. LUT查找表

# 1.1 LUT查找表原理

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464282-bd564c26-32f8-493f-ae8f-aa480f080344.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464282-bd564c26-32f8-493f-ae8f-aa480f080344.png)

---

根据一定的规则将数据映射

# 1.2 LUT查找表函数

void LUT(inputArray src,inputArray lut,outputArray dst)

---

- src：输入图像矩阵，其数据类型只能是CV_8U
- lut：256个像素灰度值的查找表，单通道或者与src通道相同
- dst：输出图像矩阵，其尺寸与src相同，数据类型与lut相同

# 1.3 实例

// LUT查找表第一层

uchar lut[256];

for (int i = 0; i < 256; i++)

{

if (i <= 100)

{

lut [i] = 0;

}

if (i > 100 && i <= 200)

{

lut[i] = 100;

}

if (i > 200)

{

lut[i] = 255;

}

}

Mat lutOne(1, 256, CV_8UC1, lut);

// LUT查找表第二层

uchar lut2[256];

for (int i = 0; i < 256; i++)

{

if (i <= 100)

{

lut2[i] = 0;

}

if (i > 100 && i <= 150)

{

lut2[i] = 100;

}

if (i > 150 && i <= 200)

{

lut2[i] = 150;

}

if (i > 200)

{

lut2[i] = 255;

}

}

Mat lutTwo(1, 256, CV_8UC1, lut2);

// LUT查找表第三层

uchar lut3[256];

for (int i = 0; i < 256; i++)

{

if (i <= 100)

{

lut3[i] = 100;

}

if (i > 100 && i <= 200)

{

lut3[i] = 200;

}

if (i > 200)

{

lut3[i] = 255;

}

}

Mat lutThree(1, 256, CV_8UC1, lut3);

// 拥有三通道的LUT查找表矩阵

vector<Mat> lutMats;

lutMats.push_back(lutOne);

lutMats.push_back(lutTwo);

lutMats.push_back(lutThree);

Mat lutTree;

merge(lutMats, lutTree);

// 计算图像的查找表

Mat img = imread("./leno.jpg", IMREAD_COLOR);

Mat gray, out1, out2, out3;

LUT (img, lutOne, out1);

LUT(img, lutTwo, out2);

LUT(img, lutThree, out3);

imshow ("img", img);

imshow("out1", out1);

imshow("out2", out2);

imshow("out3", out3);

waitKey(0);

---

# 2. 图像尺寸变换

# 2.1 图像插值原理

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464313-18737f86-fded-4e7b-90cf-653fb6bf3096.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464313-18737f86-fded-4e7b-90cf-653fb6bf3096.png)

---

**如何根据现有的像素推断临近的像素**

# 2.2 图像缩放

void resize(inputArray src,outputArray dst,size dsize,double fx=0,double fy=0,int interpolation);

---

- src：输入图像
- dst：输出图像，图像的数据类型与src相同
- dsize：输出图像的尺寸
- fx：水平轴的比例因子，如果将水平轴变为原来的两倍，则赋值为2；
- fy：垂直轴的比例因子，如果将垂直轴变为原来的两倍，则赋值为2
- interpolation：差值方法的标识

# 2.3 图像翻转

void flip(inputArray src,outputArray dst,int flipCode);

---

- src：输入图像
- dst：输出图像，与src具有相同的大小和数据类型以及通道数
- flipCode：翻转方式标志，数值大于0表示绕y轴进行翻转；数值等于0，表示绕x轴进行翻转；数值小于0表示绕两个轴进行旋转

# 2.4 图像的拼接

void hconcat(inputArray src1,inputArray src2,outputArray,dst);

void vconcat(inputArray src1,inputArray src2,outputArray dst);

---

- src1：第一个需要连接的mat矩阵
- src2：第二个需要连接的mat矩阵，与第一个参数具有相同的宽度，数据类型和通道数
- dst：连接后的mat矩阵

# 2.5 实例

// 1. 图像的缩放

Mat img = imread("./leno.jpg", IMREAD_COLOR);

Mat img_resize;

resize(img, img_resize, Size(100, 100));

imshow("img_resize", img_resize);

// 2. 图像的翻转

Mat img_flip;

flip(img, img_flip, 1);

imshow("img_flip", img_flip);

// 3. 图像的拼接

Mat img1 = imread("./leno.jpg", IMREAD_COLOR);

Mat img2 = imread("./R-C.jpg", IMREAD_COLOR);

Mat img_h, img_v;

hconcat(img1, img2, img_h);

vconcat(img1, img2, img_v);

imshow("img_h", img_h);

imshow("img_v", img_v);

waitKey(0);

---

# 3. 图像的仿射变换

# 3.1 仿射变换介绍

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464354-54d524b4-68e4-43da-a530-f371fe05e19c.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464354-54d524b4-68e4-43da-a530-f371fe05e19c.png)

---

# 3.2 仿射变换函数

void cv::warpAffine    (InputArray     src,

OutputArray     dst,

InputArray     M,

Size     dsize,

int     flags = INTER_LINEAR,

int     borderMode = BORDER_CONSTANT,

const Scalar &     borderValue = Scalar()

)

---

- src：输入图像
- dst：仿射变换后输出图像，与src数据类型相同，但是尺寸与dsize相同
- M：2*3的变换矩阵
- dsize：输出图像的尺寸
- flage：插值方法标志
- borderMode：像素边界外推方法发标志
- borderValue：填充外界使用的数值，默认为0

边界填充方法和对应标志

Mat img = imread("./leno.jpg", IMREAD_COLOR);

// 1. 仿射变换矩阵

Mat M = Mat::zeros(2, 3, CV_32FC1);

M.at<float>(0, 0) = 1.0f;

M.at<float>(0, 2) = 100.0f;

M.at<float>(1, 1) = 1.0f;

M.at<float>(1, 2) = 100.0f;

// 2. 仿射变换

Mat img_warp;

warpAffine(img, img_warp, M, Size(img.cols, img.rows));

imshow("img_warp", img_warp);

waitKey(0);

---

# 3.3 图像旋转

Mat cv::getRotationMatrix2D    (Point2f center,

double     angle,

double     scale

)

---

- center：图像旋转的中心位置
- angle：图像旋转的角度，单位为度，正值为逆时针旋转
- scle：两个轴的比例因子，可以实现旋转过程中的图像缩放，不缩放输入1

// 2. 图像的旋转

Mat M2 = getRotationMatrix2D(Point2f(img.cols / 2, img.rows / 2), 45, 1);

---

# 3.4 仿射变换矩阵计算

Mat cv::getAffineTransform    (const Point2f     src[],

const Point2f     dst[]

)

---

- src[]：原图像中的三个像素坐标
- dst[]：目标图像中的三个像素坐标

// 3. 图像的仿射变换矩阵

Point2f srcTri[3];

Point2f dstTri[3];

srcTri[0] = Point2f(0, 0);

srcTri[1] = Point2f(img.cols - 1, 0);

srcTri[2] = Point2f(0, img.rows - 1);

dstTri[0] = Point2f(img.cols * 0.0f, img.rows * 0.33f);

dstTri[1] = Point2f(img.cols * 0.85f, img.rows * 0.25f);

dstTri[2] = Point2f(img.cols * 0.15f, img.rows * 0.7f);

Mat M3 = getAffineTransform(srcTri, dstTri);

---

# 4. 图像透视变换

# 4.1 透视变换介绍

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464322-5dac6f21-49bc-4eb5-8981-6d06a3b4cf79.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464322-5dac6f21-49bc-4eb5-8981-6d06a3b4cf79.png)

---

# 4.2 计算透视变换矩阵函数

Mat cv::getPerspectiveTransform    (InputArray     src,

InputArray         dst,

int             solveMethod = DECOMP_LU

)

---

- src[]：原图像中的四个像素坐标
- dst[]：目标图像中的四个像素坐标
- solveMethod：计算透视变换矩阵方法的标志

计算方法标志

| **标志参数** | **简记** | **作用** |
| --- | --- | --- |
| DECOMP_LU | 0 | 最佳主轴元素的高斯消元方法 |
| DECOMP_SVD | 1 | 奇异值分解（SVD）方法 |
| DECOMP_EIG | 2 | 特征值分解法 |
| DECOMP_CHOLESKY | 3 | Cholesky分解法 |
| DECOMP_QR | 4 | QR分解法 |
| DECOMP_NORMAL | 16 | 使用正规方程公式，可以去前面的标志一起使用 |

// 4. 图像的透视变换

Point2f srcQuad[4];

Point2f dstQuad[4];

srcQuad[0] = Point2f(0, 0);

srcQuad[1] = Point2f(img.cols - 1, 0);

srcQuad[2] = Point2f(img.cols - 1, img.rows - 1);

srcQuad[3] = Point2f(0, img.rows - 1);

dstQuad[0] = Point2f(img.cols * 0.05f, img.rows * 0.33f);

dstQuad[1] = Point2f(img.cols * 0.9f, img.rows * 0.25f);

dstQuad[2] = Point2f(img.cols * 0.8f, img.rows * 0.9f);

dstQuad[3] = Point2f(img.cols * 0.2f, img.rows * 0.7f);

Mat M4 = getPerspectiveTransform(srcQuad, dstQuad);

---

# 4.3 透视变换函数

void cv::hal::warpPerspective(int     src_type,

const uchar *     src_data,

size_t     src_step,

int     src_width,

int     src_height,

uchar *     dst_data,

size_t     dst_step,

int     dst_width,

int     dst_height,

const double     M[9],

int     interpolation,

int     borderType,

const double     borderValue[4]

)

---

实例：

// 5. 图像的透视变换函数

Mat img_perspective;

warpPerspective(img, img_perspective, M4, Size(img.cols, img.rows));

---

效果：

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464436-6c7d450f-d9a9-4dd9-8527-08e836d93748.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717320464436-6c7d450f-d9a9-4dd9-8527-08e836d93748.png)

---