# 第一章 primitives

# c++ 应用程序

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717315120963-6f25c21e-599e-4923-9f24-94db6b5870ef.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717315120963-6f25c21e-599e-4923-9f24-94db6b5870ef.png)

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717315120668-ab59dc1c-033b-4b7a-a921-20778016042a.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717315120668-ab59dc1c-033b-4b7a-a921-20778016042a.png)

# 基本工具

在c++中内存的申请是通过new来实现的，释放内存是delete来释放

当我们申请数组内存的时候，形式如下

float *num = new float[8];

这里我们申请了8个内存，释放内存的时候，需要添加[]中括号来释放数组内存

delete[] num;

这里为什么使用中括号[]来释放内存，不使用的话会发生什么情况

如果不使用[]中括号来释放内存，会造成内存泄漏，以为不加[]，编译器会认为是只释放一次内存

而加上[]中括号，则会依次释放申请的内存

所以结论是：申请内存不会报错，而释放内存如果不当，就会造成内存泄漏的问题

在c++中内存的申请是在栈上面，原则是先进后出

new申请内存就是将内存申请在栈上面，释放内存则是先释放后申请的内存

比如申请的内存是1，2，3   释放内存则是3，2，1

栈堆

栈：

1. 由系统自动管理，以执行函数为单位
2. 空间大小编译时确定（参数+局部变量）
3. 函数执行时，系统自动分配一个stack
4. 函数执行结束，系统立即自动回收stack

堆

1. 在c++中由程序员手动控制
2. 手动分配new和malloc
3. 手动释放delete和free
4. 具有全局性，总体无大小限制
5. 容易造成内存泄漏

变量模型与使用

三种变量模型：对象，指针，引用

三种使用场景：声明对象，传参，返回值

可不可以没有堆只有栈？

不能。栈的空间是固定的，但程序运行的时候，内存的大小是不可能在

编译的时候确定，可能运行的时候才可以确定内存的大小，所以不能没

有堆，只有栈

可不可以没有栈只有堆？

不可以。栈是管理函数的，因为栈是先进后出，函数在调用的时候，

其实也是一个栈的过程