# 第七章 堆，栈与内存管理

**output函数**

// 2-4 output函数

#include <iostream>

ostream& operator << (ostream& os,const String& str)

{

os << str.get_c_str();

return os;

}

{

String s1("hello");

cout << s1;

}

---

# 8.1 所谓栈stack（栈），所谓heap（堆）

**stack**：是存在于某作用域（scope）的一块内存空间（memory space）。例如当你调用函数，函数本身即会形成形成一个stack用来放置他所接收的参数，以及返回地址

在函数本体内声明的任何变量，其所使用的内存块都取自上述stack

**heap**：或谓system heap，是指由操作系统提供的一块global内存空间，程序可动态分配的（dynamiallocated）从某中获得若干区块（blocks）

class Complex{...};

...

{

Complex c1(1,2);

Complex* p = new Complex(3);

}

---

c1所占用的空间来自stack

c3所占用的空间所动态分配的，用户自己申请的，所以在使用完后要手动的释放，delete申请的空间

### 8.1.1 stack object的生命周期

class Complex {...};

...

{

Complex c1(1,2);

}

---

c1便是所谓的stack object，其生命在作用域（scope）结束之际结束

这种作用域内的object，又称之为atou object，因为他会被 **自动** 清理

### 8.1.2 static local object的生命周期

class Complex{...};

...

{

static Complex c2(1,2);

}

---

c2便是所谓static object，其生命周期在作用域（scope）结束之后仍然存在，直到整个程序结束

### 8.1.3 global object的生命周期

class Complex{...};

...

Complex c2(1,2);

int main()

{

...

}

---

c2便是所谓global object，其生命周期在整个程序结束之后才结束

你也可以把他视为一种static object，其作用域是 **整个程序**

### 8.1.4 heap object的生命周期

class Complex {...};

...

{

Complex* p = new Complex;

...

delete p;

}

---

p所指的便是heap object，其生命周期在他被delete之际结束

class Complex {...};

...

{

Complex* p = new Complex;

}

---

以上出现内存泄漏（memory leak）,因为当作用域结束，p所指的heap object仍然存在，但指针p的生命却结束了，作用域之外再也看不到p（也就没有机会delete p）

### 8.1.5 new 先memory，再调用ctor

Complex* pc = new Complex(1,2);

编译器转换为：

1. void* mem = operator new (sizeof(Complex)); // 分配内存
2. pc = static_cast<Complex*>(mem); //转型
3. pc->Comlex::Complex(1,2);// 构造函数

---

解释

1. new内部调用malloc(n)
2. Comlex::Complex(pc,1,2);// pc->this

### 8.1.6 delete：先调用dtor，在释放memory

String* ps = new String("Hello");

...

delete ps;

编译器转换为：

1. String::~String(ps); // 析构函数
2. operstor delete(ps); // 释放内存

---

delete内部调用free(ps);

# 8.2 动态分配所得的内存块

# 8.3 动态分配所得的array

**arry new需要搭配 arry delete**