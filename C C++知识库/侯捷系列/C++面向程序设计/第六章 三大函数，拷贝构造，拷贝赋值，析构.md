# 第六章 三大函数，拷贝构造，拷贝赋值，析构

# 7.1 String class

// string.h

#ifndef __MYSTRING__

#define __MYSTRING__

// 1

class String

{

...

};

// 2

String::function(...)...

Global-function(...)...

#endif

---

// string-test.cp

int main()

{

String s1();

String s2("hello");

String s3(s1);

cout << s3 << endl;

s3 = s2;

cout << s3 << endl;

}

---

1. 拷贝构造和拷贝赋值编译器会自动生成
2. 要是指针类的拷贝构造和拷贝赋值，就是简单的把需要拷贝的指针赋值过去，不是真正的拷贝。所以说类中如果有指针的话，不能使用编译器自动生成的拷贝函数

# 7.2 Big Three，三个特殊函数

class String

{

public:

String(const char* cstr = 0);

String(const String& str);  // 拷贝构造

String& operator = (const String& str);

~String();

char* get_c_str() const {return m_data;}

private:

char* m_data;

}

---

### 7.2.1 ctor和dtor(构造函数和析构函数)

// 2-1

inline

String::String(const char* cstr = 0)

{

if(catr)

{

m_data = new char[strlen(cstr)+1];

strcpy(m_data,cstr);

}

else

{

// 未指定初值

m_data = new char[1];

- m_data = '\0';

}

}

inline

String::~String()

{

detale[] m_data;

}

{

String s1();

String s2("hello");

String* p = new String("hello");

delete p;

}

---

**c++里面如何确定字符串的长度?**

1. 延续c语言概念，有一个指针指向字符串的开头，在字符串的结尾有一个'\0'的字符表示字符串的结尾
2. 另外一个就是字符串的开头，有一个数表示字符串的长度

强调几点：

1. 你的class类中如果有指针多半是用来动态分配内存的
2. 析构函数的作用是将分配的内存释放掉
3. 如果不释放分配的内存，会造成内存泄漏

### 7.2.2 class with pointer members必须有copy ctor和copy op=

浅拷贝：系统自带带拷贝函数就叫做浅拷贝，浅拷贝只会把指针拷贝给对方

深拷贝：我们需要自定义（自己写）的拷贝函数就叫做深拷贝

# 7.3 copy ctor(拷贝构造函数)

// 2-2

inline

String::String(const String& str)

{

m_data = new char[strlen(str.mdata)+1];

strcpy(m_data,str.m_data);

}

{

String s1("hello");

String s2(s1);

//  String s2=s1;

}

---

# 7.4 copy assignment operator(拷贝构造函数)

// 2-3

inlie

String& String::operator = (const String& str)

{

if(this == &str)

{

// 检测自我赋值

return *this;

}

delete[] m_data;

m_data = new char[strlen(str.m_data)+1];

strcpy(m_data,str.m_data);

return *this;

}

{

String s1("hello");

String s2(s1);

s2 = s1;

}

---

1. 清空原有的数据
2. 将右值的大小赋值给左值
3. 再将左值赋值给右值，深拷贝，数据完全一样

**一定要在operator= 中检测是否self assignment**

如果没有检测是否是一个指针，则在程序中会delete赋值的值