# 第四章 参数传递与返回值

# 4.1 构造函数放到private区域

1. 

如果把函数放到private(私有的)区域表示该函数不可以被外界调用，但如果创建该对象的时候是会自动调用构造函数的。

1. 

但是并不表示不会有人把构造函数放到private区域，在我不想被外界创建对象的情况下，构造函数是放到private区域。

例子：

// Singleton 单例

class A

{

public:

static A& getInstance();

setup() {....}

private:

A();

A(const A& rhs);

...

}

A& A::getInstance()

{

static A a;

return a;

}

---

# 4.2 常量成员函数

class complex

{

public:

complex(double r = 0;double i = 0) // 默认值

: re(r),im(i)   // 初值列 构造函数特有的语法

{}

complex& operator += (const complex&);

double real () const {return re;}

double imag () const {return im;}

private:

double re,im;

friend complex& __doapl(complex*,const complex&);

};

---

1. 对于class类中的函数分为两类：会改变数据的和不会改变数据的
2. 不会改变数据的函数加上 **const**
3. 在设计接口的时候，一定要考虑加不加 const 关键字，如果不加会产生什么情况：

在const函数中调用非const成员函数上语法错误

# 4.3 参数传递（pass by value VS pass by reference）to const

传递值 VS 传递引用

// pass by value

complex(double r = 0;double i = 0)

: re(r),im(i)

---

// pass by reference

complex& operator += (const complex&);

---

1. 

语法上：加 **引用符号** 的叫做 by reference，不加的叫做  by value

在这里并不是取地址的意思

1. 

值传递：是将全部的值传递过去

1. 

引用传递：是将该值的地址传过去，C++中叫做引用传递

引用在本质上是一个指针，所以说传递引用就是传递指针，但是形式上更加漂亮，速递效率更高

1. 

要建立一个良好的习惯：传递值的时候，尽量全部传递reference而不是 value

1. 

但如果另外地方调用该值并且改变该引用的值的话，相应的也会改变，想要不被改变的话需要加 const。如果强制修改的话，编译器会报错

# 4.4 返回值传递：return by value VS return by reference (to const)

1. c++ 语言比上其他面向对象的语言更加注重效率，所以我们要在任何一个小的细节上面，注重效率，养成习惯
2. 返回值也要尽量 **by reference**
3. 返回值类型：在函数名称前面的叫做返回值类型

# 4.5 friend(友元)

语法：

// 友元语法

friend complex& __doapl(complex*,const complex&);

---

在设计class的时候，我们把数据部分放到private区域，表示该数据是私有的，这就叫做封装

但是friend修饰的函数则可以访问该私有的数据部分

inline complex&

__doapl(complex* ths,const complex& r)

{

// 自由的取得friend的private成员

ths->re +=r.re;

ths->im +=r.im;

return *ths;

}

---

在c++中是强调封装的概念，而friend则打破了封装，所以尽量少使用friend，但是friend是比上其他函数效率更高

### 4.5.1 相同class的各个object互为friend（友元）

例子

class complex

{

public:

complex (double r = 0,double i = 0)

: re (r),im(i)

{}

int func(const complex& param)

{return param.re + param.im;}

private:

double re,im;

}

---

{

complex c1(2,1);

complex c2;

c2.func(c1);

}

---

# 4.6 class body外的各种dingy（definitions）

什么情况下可以pass by reference

什么情况下可以return by reference

1. 数据要放到private区域
2. 参数传递要用reference，加不加const看具体情况
3. 返回值也尽量使用reference
4. 在类的本体类中函数需要加const的加上const
5. 构造函数的特殊用法（:）

// do assignment pius

inline complex&

__doapl(complex* ths,const complex& r)

{

ths->re += r.re;    // 第一个参数将会被改变

ths->im += r.im;    // 第二个参数不会被改变

return *ths;

}

inline complex&

complex::operator += (const complex& r)

{

return __doaple(this ,r);

}

---

函数在传递参数的时候会有两种情况：

1. 重新创造一个值来进行参数传递
2. 从现有的参数列表中选择一个参数，作为参数传递的值

在第二中情况下你就不可以return by reference