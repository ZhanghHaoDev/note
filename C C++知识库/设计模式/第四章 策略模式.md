# 第四章 策略模式

# 动机

- 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担
- 面向对象的复用指的是二进制单位的复用，不是片段代码的复制粘贴

# 模式定义

定义一系列算法把他们一个个封装起来。并且使他们可互相替换（变化）/该模式使得算法可独立于使用他的客户程序（稳定）而变化（扩展，子类化）

# 结构

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717314375503-b2e2f479-07a8-437f-b53f-275d38b1e8f3.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717314375503-b2e2f479-07a8-437f-b53f-275d38b1e8f3.png)

---

strategy是稳定的基类，派生类（子类）的变化的

# 要点总结

- Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便的根据需要在各个算法之间进行切换
- Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式（if。。。else。。if）
- 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销