# 第六章 装饰模式

# 单一职责模式

在软件组件的设计中，如果责任划分的不清楚，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划分清责任

# 动机

- 在某些情况下我们可能会“过度的使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀

# 模式定义

动态（组合）的给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码和减少子类个数）

# 结构

![https://cdn.nlark.com/yuque/0/2024/png/23087967/1717314444961-3ca9ec9b-7e42-4b98-853b-951bb9fa667c.png](https://cdn.nlark.com/yuque/0/2024/png/23087967/1717314444961-3ca9ec9b-7e42-4b98-853b-951bb9fa667c.png)

---

# 要点总结

- 通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“子类衍生问题”
- Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Componet的组合关系，即Decorator类又使用了另外的一个Componet类
- Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体在多个方向上的扩展功能”--是为“装饰”的含义